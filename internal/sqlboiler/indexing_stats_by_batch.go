// Code generated by SQLBoiler 4.19.7 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sqlboiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// IndexingStatsByBatch is an object representing the database table.
type IndexingStatsByBatch struct {
	BatchID              null.String       `boil:"batch_id" json:"batch_id,omitempty" toml:"batch_id" yaml:"batch_id,omitempty"`
	ProjectID            null.String       `boil:"project_id" json:"project_id,omitempty" toml:"project_id" yaml:"project_id,omitempty"`
	IngestionMethod      null.String       `boil:"ingestion_method" json:"ingestion_method,omitempty" toml:"ingestion_method" yaml:"ingestion_method,omitempty"`
	TotalRecords         null.Int64        `boil:"total_records" json:"total_records,omitempty" toml:"total_records" yaml:"total_records,omitempty"`
	IndexedCount         null.Int64        `boil:"indexed_count" json:"indexed_count,omitempty" toml:"indexed_count" yaml:"indexed_count,omitempty"`
	FailedCount          null.Int64        `boil:"failed_count" json:"failed_count,omitempty" toml:"failed_count" yaml:"failed_count,omitempty"`
	PendingCount         null.Int64        `boil:"pending_count" json:"pending_count,omitempty" toml:"pending_count" yaml:"pending_count,omitempty"`
	SuccessRatePercent   types.NullDecimal `boil:"success_rate_percent" json:"success_rate_percent,omitempty" toml:"success_rate_percent" yaml:"success_rate_percent,omitempty"`
	AvgProcessingTimeMS  types.NullDecimal `boil:"avg_processing_time_ms" json:"avg_processing_time_ms,omitempty" toml:"avg_processing_time_ms" yaml:"avg_processing_time_ms,omitempty"`
	BatchStartedAt       null.Time         `boil:"batch_started_at" json:"batch_started_at,omitempty" toml:"batch_started_at" yaml:"batch_started_at,omitempty"`
	BatchCompletedAt     null.Time         `boil:"batch_completed_at" json:"batch_completed_at,omitempty" toml:"batch_completed_at" yaml:"batch_completed_at,omitempty"`
	BatchDurationSeconds types.NullDecimal `boil:"batch_duration_seconds" json:"batch_duration_seconds,omitempty" toml:"batch_duration_seconds" yaml:"batch_duration_seconds,omitempty"`
}

var IndexingStatsByBatchColumns = struct {
	BatchID              string
	ProjectID            string
	IngestionMethod      string
	TotalRecords         string
	IndexedCount         string
	FailedCount          string
	PendingCount         string
	SuccessRatePercent   string
	AvgProcessingTimeMS  string
	BatchStartedAt       string
	BatchCompletedAt     string
	BatchDurationSeconds string
}{
	BatchID:              "batch_id",
	ProjectID:            "project_id",
	IngestionMethod:      "ingestion_method",
	TotalRecords:         "total_records",
	IndexedCount:         "indexed_count",
	FailedCount:          "failed_count",
	PendingCount:         "pending_count",
	SuccessRatePercent:   "success_rate_percent",
	AvgProcessingTimeMS:  "avg_processing_time_ms",
	BatchStartedAt:       "batch_started_at",
	BatchCompletedAt:     "batch_completed_at",
	BatchDurationSeconds: "batch_duration_seconds",
}

var IndexingStatsByBatchTableColumns = struct {
	BatchID              string
	ProjectID            string
	IngestionMethod      string
	TotalRecords         string
	IndexedCount         string
	FailedCount          string
	PendingCount         string
	SuccessRatePercent   string
	AvgProcessingTimeMS  string
	BatchStartedAt       string
	BatchCompletedAt     string
	BatchDurationSeconds string
}{
	BatchID:              "indexing_stats_by_batch.batch_id",
	ProjectID:            "indexing_stats_by_batch.project_id",
	IngestionMethod:      "indexing_stats_by_batch.ingestion_method",
	TotalRecords:         "indexing_stats_by_batch.total_records",
	IndexedCount:         "indexing_stats_by_batch.indexed_count",
	FailedCount:          "indexing_stats_by_batch.failed_count",
	PendingCount:         "indexing_stats_by_batch.pending_count",
	SuccessRatePercent:   "indexing_stats_by_batch.success_rate_percent",
	AvgProcessingTimeMS:  "indexing_stats_by_batch.avg_processing_time_ms",
	BatchStartedAt:       "indexing_stats_by_batch.batch_started_at",
	BatchCompletedAt:     "indexing_stats_by_batch.batch_completed_at",
	BatchDurationSeconds: "indexing_stats_by_batch.batch_duration_seconds",
}

// Generated where

var IndexingStatsByBatchWhere = struct {
	BatchID              whereHelpernull_String
	ProjectID            whereHelpernull_String
	IngestionMethod      whereHelpernull_String
	TotalRecords         whereHelpernull_Int64
	IndexedCount         whereHelpernull_Int64
	FailedCount          whereHelpernull_Int64
	PendingCount         whereHelpernull_Int64
	SuccessRatePercent   whereHelpertypes_NullDecimal
	AvgProcessingTimeMS  whereHelpertypes_NullDecimal
	BatchStartedAt       whereHelpernull_Time
	BatchCompletedAt     whereHelpernull_Time
	BatchDurationSeconds whereHelpertypes_NullDecimal
}{
	BatchID:              whereHelpernull_String{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"batch_id\""},
	ProjectID:            whereHelpernull_String{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"project_id\""},
	IngestionMethod:      whereHelpernull_String{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"ingestion_method\""},
	TotalRecords:         whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"total_records\""},
	IndexedCount:         whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"indexed_count\""},
	FailedCount:          whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"failed_count\""},
	PendingCount:         whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"pending_count\""},
	SuccessRatePercent:   whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"success_rate_percent\""},
	AvgProcessingTimeMS:  whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"avg_processing_time_ms\""},
	BatchStartedAt:       whereHelpernull_Time{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"batch_started_at\""},
	BatchCompletedAt:     whereHelpernull_Time{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"batch_completed_at\""},
	BatchDurationSeconds: whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_batch\".\"batch_duration_seconds\""},
}

var (
	indexingStatsByBatchAllColumns            = []string{"batch_id", "project_id", "ingestion_method", "total_records", "indexed_count", "failed_count", "pending_count", "success_rate_percent", "avg_processing_time_ms", "batch_started_at", "batch_completed_at", "batch_duration_seconds"}
	indexingStatsByBatchColumnsWithoutDefault = []string{}
	indexingStatsByBatchColumnsWithDefault    = []string{"batch_id", "project_id", "ingestion_method", "total_records", "indexed_count", "failed_count", "pending_count", "success_rate_percent", "avg_processing_time_ms", "batch_started_at", "batch_completed_at", "batch_duration_seconds"}
	indexingStatsByBatchPrimaryKeyColumns     = []string{}
	indexingStatsByBatchGeneratedColumns      = []string{}
)

type (
	// IndexingStatsByBatchSlice is an alias for a slice of pointers to IndexingStatsByBatch.
	// This should almost always be used instead of []IndexingStatsByBatch.
	IndexingStatsByBatchSlice []*IndexingStatsByBatch
	// IndexingStatsByBatchHook is the signature for custom IndexingStatsByBatch hook methods
	IndexingStatsByBatchHook func(context.Context, boil.ContextExecutor, *IndexingStatsByBatch) error

	indexingStatsByBatchQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	indexingStatsByBatchType           = reflect.TypeOf(&IndexingStatsByBatch{})
	indexingStatsByBatchMapping        = queries.MakeStructMapping(indexingStatsByBatchType)
	indexingStatsByBatchInsertCacheMut sync.RWMutex
	indexingStatsByBatchInsertCache    = make(map[string]insertCache)
	indexingStatsByBatchUpdateCacheMut sync.RWMutex
	indexingStatsByBatchUpdateCache    = make(map[string]updateCache)
	indexingStatsByBatchUpsertCacheMut sync.RWMutex
	indexingStatsByBatchUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var indexingStatsByBatchAfterSelectMu sync.Mutex
var indexingStatsByBatchAfterSelectHooks []IndexingStatsByBatchHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *IndexingStatsByBatch) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range indexingStatsByBatchAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddIndexingStatsByBatchHook registers your hook function for all future operations.
func AddIndexingStatsByBatchHook(hookPoint boil.HookPoint, indexingStatsByBatchHook IndexingStatsByBatchHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		indexingStatsByBatchAfterSelectMu.Lock()
		indexingStatsByBatchAfterSelectHooks = append(indexingStatsByBatchAfterSelectHooks, indexingStatsByBatchHook)
		indexingStatsByBatchAfterSelectMu.Unlock()
	}
}

// One returns a single indexingStatsByBatch record from the query.
func (q indexingStatsByBatchQuery) One(ctx context.Context, exec boil.ContextExecutor) (*IndexingStatsByBatch, error) {
	o := &IndexingStatsByBatch{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "sqlboiler: failed to execute a one query for indexing_stats_by_batch")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all IndexingStatsByBatch records from the query.
func (q indexingStatsByBatchQuery) All(ctx context.Context, exec boil.ContextExecutor) (IndexingStatsByBatchSlice, error) {
	var o []*IndexingStatsByBatch

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "sqlboiler: failed to assign all query results to IndexingStatsByBatch slice")
	}

	if len(indexingStatsByBatchAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all IndexingStatsByBatch records in the query.
func (q indexingStatsByBatchQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "sqlboiler: failed to count indexing_stats_by_batch rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q indexingStatsByBatchQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "sqlboiler: failed to check if indexing_stats_by_batch exists")
	}

	return count > 0, nil
}

// IndexingStatsByBatches retrieves all the records using an executor.
func IndexingStatsByBatches(mods ...qm.QueryMod) indexingStatsByBatchQuery {
	mods = append(mods, qm.From("\"schema_knowledge\".\"indexing_stats_by_batch\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"schema_knowledge\".\"indexing_stats_by_batch\".*"})
	}

	return indexingStatsByBatchQuery{q}
}
