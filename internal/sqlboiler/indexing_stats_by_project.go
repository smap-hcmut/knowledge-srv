// Code generated by SQLBoiler 4.19.7 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package sqlboiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// IndexingStatsByProject is an object representing the database table.
type IndexingStatsByProject struct {
	ProjectID          null.String       `boil:"project_id" json:"project_id,omitempty" toml:"project_id" yaml:"project_id,omitempty"`
	TotalIndexed       null.Int64        `boil:"total_indexed" json:"total_indexed,omitempty" toml:"total_indexed" yaml:"total_indexed,omitempty"`
	TotalFailed        null.Int64        `boil:"total_failed" json:"total_failed,omitempty" toml:"total_failed" yaml:"total_failed,omitempty"`
	TotalPending       null.Int64        `boil:"total_pending" json:"total_pending,omitempty" toml:"total_pending" yaml:"total_pending,omitempty"`
	TotalReindexing    null.Int64        `boil:"total_reindexing" json:"total_reindexing,omitempty" toml:"total_reindexing" yaml:"total_reindexing,omitempty"`
	TotalAll           null.Int64        `boil:"total_all" json:"total_all,omitempty" toml:"total_all" yaml:"total_all,omitempty"`
	SuccessRatePercent types.NullDecimal `boil:"success_rate_percent" json:"success_rate_percent,omitempty" toml:"success_rate_percent" yaml:"success_rate_percent,omitempty"`
	AvgTotalTimeMS     types.NullDecimal `boil:"avg_total_time_ms" json:"avg_total_time_ms,omitempty" toml:"avg_total_time_ms" yaml:"avg_total_time_ms,omitempty"`
	AvgEmbeddingTimeMS types.NullDecimal `boil:"avg_embedding_time_ms" json:"avg_embedding_time_ms,omitempty" toml:"avg_embedding_time_ms" yaml:"avg_embedding_time_ms,omitempty"`
	AvgUpsertTimeMS    types.NullDecimal `boil:"avg_upsert_time_ms" json:"avg_upsert_time_ms,omitempty" toml:"avg_upsert_time_ms" yaml:"avg_upsert_time_ms,omitempty"`
	MinTotalTimeMS     null.Int          `boil:"min_total_time_ms" json:"min_total_time_ms,omitempty" toml:"min_total_time_ms" yaml:"min_total_time_ms,omitempty"`
	MaxTotalTimeMS     null.Int          `boil:"max_total_time_ms" json:"max_total_time_ms,omitempty" toml:"max_total_time_ms" yaml:"max_total_time_ms,omitempty"`
	LastIndexedAt      null.Time         `boil:"last_indexed_at" json:"last_indexed_at,omitempty" toml:"last_indexed_at" yaml:"last_indexed_at,omitempty"`
	FirstCreatedAt     null.Time         `boil:"first_created_at" json:"first_created_at,omitempty" toml:"first_created_at" yaml:"first_created_at,omitempty"`
	LastCreatedAt      null.Time         `boil:"last_created_at" json:"last_created_at,omitempty" toml:"last_created_at" yaml:"last_created_at,omitempty"`
	TotalKafka         null.Int64        `boil:"total_kafka" json:"total_kafka,omitempty" toml:"total_kafka" yaml:"total_kafka,omitempty"`
	TotalAPI           null.Int64        `boil:"total_api" json:"total_api,omitempty" toml:"total_api" yaml:"total_api,omitempty"`
}

var IndexingStatsByProjectColumns = struct {
	ProjectID          string
	TotalIndexed       string
	TotalFailed        string
	TotalPending       string
	TotalReindexing    string
	TotalAll           string
	SuccessRatePercent string
	AvgTotalTimeMS     string
	AvgEmbeddingTimeMS string
	AvgUpsertTimeMS    string
	MinTotalTimeMS     string
	MaxTotalTimeMS     string
	LastIndexedAt      string
	FirstCreatedAt     string
	LastCreatedAt      string
	TotalKafka         string
	TotalAPI           string
}{
	ProjectID:          "project_id",
	TotalIndexed:       "total_indexed",
	TotalFailed:        "total_failed",
	TotalPending:       "total_pending",
	TotalReindexing:    "total_reindexing",
	TotalAll:           "total_all",
	SuccessRatePercent: "success_rate_percent",
	AvgTotalTimeMS:     "avg_total_time_ms",
	AvgEmbeddingTimeMS: "avg_embedding_time_ms",
	AvgUpsertTimeMS:    "avg_upsert_time_ms",
	MinTotalTimeMS:     "min_total_time_ms",
	MaxTotalTimeMS:     "max_total_time_ms",
	LastIndexedAt:      "last_indexed_at",
	FirstCreatedAt:     "first_created_at",
	LastCreatedAt:      "last_created_at",
	TotalKafka:         "total_kafka",
	TotalAPI:           "total_api",
}

var IndexingStatsByProjectTableColumns = struct {
	ProjectID          string
	TotalIndexed       string
	TotalFailed        string
	TotalPending       string
	TotalReindexing    string
	TotalAll           string
	SuccessRatePercent string
	AvgTotalTimeMS     string
	AvgEmbeddingTimeMS string
	AvgUpsertTimeMS    string
	MinTotalTimeMS     string
	MaxTotalTimeMS     string
	LastIndexedAt      string
	FirstCreatedAt     string
	LastCreatedAt      string
	TotalKafka         string
	TotalAPI           string
}{
	ProjectID:          "indexing_stats_by_project.project_id",
	TotalIndexed:       "indexing_stats_by_project.total_indexed",
	TotalFailed:        "indexing_stats_by_project.total_failed",
	TotalPending:       "indexing_stats_by_project.total_pending",
	TotalReindexing:    "indexing_stats_by_project.total_reindexing",
	TotalAll:           "indexing_stats_by_project.total_all",
	SuccessRatePercent: "indexing_stats_by_project.success_rate_percent",
	AvgTotalTimeMS:     "indexing_stats_by_project.avg_total_time_ms",
	AvgEmbeddingTimeMS: "indexing_stats_by_project.avg_embedding_time_ms",
	AvgUpsertTimeMS:    "indexing_stats_by_project.avg_upsert_time_ms",
	MinTotalTimeMS:     "indexing_stats_by_project.min_total_time_ms",
	MaxTotalTimeMS:     "indexing_stats_by_project.max_total_time_ms",
	LastIndexedAt:      "indexing_stats_by_project.last_indexed_at",
	FirstCreatedAt:     "indexing_stats_by_project.first_created_at",
	LastCreatedAt:      "indexing_stats_by_project.last_created_at",
	TotalKafka:         "indexing_stats_by_project.total_kafka",
	TotalAPI:           "indexing_stats_by_project.total_api",
}

// Generated where

var IndexingStatsByProjectWhere = struct {
	ProjectID          whereHelpernull_String
	TotalIndexed       whereHelpernull_Int64
	TotalFailed        whereHelpernull_Int64
	TotalPending       whereHelpernull_Int64
	TotalReindexing    whereHelpernull_Int64
	TotalAll           whereHelpernull_Int64
	SuccessRatePercent whereHelpertypes_NullDecimal
	AvgTotalTimeMS     whereHelpertypes_NullDecimal
	AvgEmbeddingTimeMS whereHelpertypes_NullDecimal
	AvgUpsertTimeMS    whereHelpertypes_NullDecimal
	MinTotalTimeMS     whereHelpernull_Int
	MaxTotalTimeMS     whereHelpernull_Int
	LastIndexedAt      whereHelpernull_Time
	FirstCreatedAt     whereHelpernull_Time
	LastCreatedAt      whereHelpernull_Time
	TotalKafka         whereHelpernull_Int64
	TotalAPI           whereHelpernull_Int64
}{
	ProjectID:          whereHelpernull_String{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"project_id\""},
	TotalIndexed:       whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_indexed\""},
	TotalFailed:        whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_failed\""},
	TotalPending:       whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_pending\""},
	TotalReindexing:    whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_reindexing\""},
	TotalAll:           whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_all\""},
	SuccessRatePercent: whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"success_rate_percent\""},
	AvgTotalTimeMS:     whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"avg_total_time_ms\""},
	AvgEmbeddingTimeMS: whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"avg_embedding_time_ms\""},
	AvgUpsertTimeMS:    whereHelpertypes_NullDecimal{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"avg_upsert_time_ms\""},
	MinTotalTimeMS:     whereHelpernull_Int{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"min_total_time_ms\""},
	MaxTotalTimeMS:     whereHelpernull_Int{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"max_total_time_ms\""},
	LastIndexedAt:      whereHelpernull_Time{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"last_indexed_at\""},
	FirstCreatedAt:     whereHelpernull_Time{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"first_created_at\""},
	LastCreatedAt:      whereHelpernull_Time{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"last_created_at\""},
	TotalKafka:         whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_kafka\""},
	TotalAPI:           whereHelpernull_Int64{field: "\"schema_knowledge\".\"indexing_stats_by_project\".\"total_api\""},
}

var (
	indexingStatsByProjectAllColumns            = []string{"project_id", "total_indexed", "total_failed", "total_pending", "total_reindexing", "total_all", "success_rate_percent", "avg_total_time_ms", "avg_embedding_time_ms", "avg_upsert_time_ms", "min_total_time_ms", "max_total_time_ms", "last_indexed_at", "first_created_at", "last_created_at", "total_kafka", "total_api"}
	indexingStatsByProjectColumnsWithoutDefault = []string{}
	indexingStatsByProjectColumnsWithDefault    = []string{"project_id", "total_indexed", "total_failed", "total_pending", "total_reindexing", "total_all", "success_rate_percent", "avg_total_time_ms", "avg_embedding_time_ms", "avg_upsert_time_ms", "min_total_time_ms", "max_total_time_ms", "last_indexed_at", "first_created_at", "last_created_at", "total_kafka", "total_api"}
	indexingStatsByProjectPrimaryKeyColumns     = []string{}
	indexingStatsByProjectGeneratedColumns      = []string{}
)

type (
	// IndexingStatsByProjectSlice is an alias for a slice of pointers to IndexingStatsByProject.
	// This should almost always be used instead of []IndexingStatsByProject.
	IndexingStatsByProjectSlice []*IndexingStatsByProject
	// IndexingStatsByProjectHook is the signature for custom IndexingStatsByProject hook methods
	IndexingStatsByProjectHook func(context.Context, boil.ContextExecutor, *IndexingStatsByProject) error

	indexingStatsByProjectQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	indexingStatsByProjectType           = reflect.TypeOf(&IndexingStatsByProject{})
	indexingStatsByProjectMapping        = queries.MakeStructMapping(indexingStatsByProjectType)
	indexingStatsByProjectInsertCacheMut sync.RWMutex
	indexingStatsByProjectInsertCache    = make(map[string]insertCache)
	indexingStatsByProjectUpdateCacheMut sync.RWMutex
	indexingStatsByProjectUpdateCache    = make(map[string]updateCache)
	indexingStatsByProjectUpsertCacheMut sync.RWMutex
	indexingStatsByProjectUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var indexingStatsByProjectAfterSelectMu sync.Mutex
var indexingStatsByProjectAfterSelectHooks []IndexingStatsByProjectHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *IndexingStatsByProject) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range indexingStatsByProjectAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddIndexingStatsByProjectHook registers your hook function for all future operations.
func AddIndexingStatsByProjectHook(hookPoint boil.HookPoint, indexingStatsByProjectHook IndexingStatsByProjectHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		indexingStatsByProjectAfterSelectMu.Lock()
		indexingStatsByProjectAfterSelectHooks = append(indexingStatsByProjectAfterSelectHooks, indexingStatsByProjectHook)
		indexingStatsByProjectAfterSelectMu.Unlock()
	}
}

// One returns a single indexingStatsByProject record from the query.
func (q indexingStatsByProjectQuery) One(ctx context.Context, exec boil.ContextExecutor) (*IndexingStatsByProject, error) {
	o := &IndexingStatsByProject{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "sqlboiler: failed to execute a one query for indexing_stats_by_project")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all IndexingStatsByProject records from the query.
func (q indexingStatsByProjectQuery) All(ctx context.Context, exec boil.ContextExecutor) (IndexingStatsByProjectSlice, error) {
	var o []*IndexingStatsByProject

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "sqlboiler: failed to assign all query results to IndexingStatsByProject slice")
	}

	if len(indexingStatsByProjectAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all IndexingStatsByProject records in the query.
func (q indexingStatsByProjectQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "sqlboiler: failed to count indexing_stats_by_project rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q indexingStatsByProjectQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "sqlboiler: failed to check if indexing_stats_by_project exists")
	}

	return count > 0, nil
}

// IndexingStatsByProjects retrieves all the records using an executor.
func IndexingStatsByProjects(mods ...qm.QueryMod) indexingStatsByProjectQuery {
	mods = append(mods, qm.From("\"schema_knowledge\".\"indexing_stats_by_project\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"schema_knowledge\".\"indexing_stats_by_project\".*"})
	}

	return indexingStatsByProjectQuery{q}
}
